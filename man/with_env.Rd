% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval.R
\name{with_env}
\alias{with_env}
\alias{locally}
\title{Evaluate an expression within a given environment}
\usage{
with_env(env, expr)

locally(..., .env = env(caller_env()))
}
\arguments{
\item{env, .env}{The environment where \code{expr} and \code{...} will be
evaluated.}

\item{expr}{An expression to evaluate.}

\item{...}{Arguments to evaluate iteratively in \code{.env}. They are
evaluated in order. If named, their result is assigned in \code{.env}.}
}
\description{
These functions evaluate \code{expr} within a given environment (\code{env}
for \code{with_env()}, or the child of the current environment for
\code{locally}). They rely on \code{\link[=eval_bare]{eval_bare()}} which features a lighter
evaluation mechanism than base R \code{\link[base:eval]{base::eval()}}, and which also has
some subtle implications when evaluting stack sensitive functions
(see help for \code{\link[=eval_bare]{eval_bare()}}).
}
\details{
\code{locally()} is equivalent to the base function \code{\link[base:local]{base::local()}} but
evaluates its arguments iteratively. It has the evaluation
semantics of \code{\link[=eval_bare]{eval_bare()}} rather than \code{\link[=eval]{eval()}}.
}
\section{Life cycle}{


These functions are experimental. Expect API changes.
}

\examples{
# locally() is like local() but supports multiple arguments which
# are defined in the environment if named:
locally(foo = "foo", toupper(foo))

# The above is equivalent to:
local({
  foo <- "foo"
  toupper(foo)
})

# locally() supports quasiquotation:
exprs <- exprs(
  foo = toupper("foo"),
  message("bar"),
  baz = paste(foo, "baz")
)
locally(!!!exprs, baz)

# with_env() is handy to create formulas with a given environment:
env <- child_env("rlang")
f <- with_env(env, ~new_formula())
identical(f_env(f), env)

# Or functions with a given enclosure:
fn <- with_env(env, function() NULL)
identical(get_env(fn), env)


# Unlike eval() it doesn't create duplicates on the evaluation
# stack. You can thus use it e.g. to create non-local returns:
fn <- function() {
  g(current_env())
  "normal return"
}
g <- function(env) {
  with_env(env, return("early return"))
}
fn()


# Since env is passed to as_environment(), it can be any object with an
# as_environment() method. For strings, the pkg_env() is returned:
with_env("base", ~mtcars)

# This can be handy to put dictionaries in scope:
with_env(mtcars, cyl)
}
